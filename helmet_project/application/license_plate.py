# -*- coding: utf-8 -*-
"""license_plate.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aRhGHpfqM5Jq_scsvlmyLV6u98Fgp_QB
"""
'''
提供的代码片段是用 Python 编写的，似乎用于自动车牌识别 (LPR)。以下是代码的分解：

**导入：**

- `cv2`：用于图像处理的 OpenCV 库
- `matplotlib.pyplot`：用于绘制图像
- `numpy`：用于数值运算

**全局变量：**

- `img_height`, `img_width`：存储图像的高度和宽度
- `gray`：图像的灰度版本
- `threshold`：二值化阈值图像
- `skip`：数组，用于跟踪已处理的目标对象

**函数：**

- `plate_recognition(box_img)`：这是主函数，它接受潜在车牌的裁剪图像并尝试识别字符。
    - 执行各种图像处理步骤，如转换为灰度、应用阈值化、查找边缘、识别潜在车牌区域，最后尝试识别这些区域内的字符。
    - 如果找不到车牌或识别分数低，则返回 "no_LP"，否则返回识别的车牌号码。
- `plot_show_save(plot, save_path=False)`：绘制图像并可选地将其保存到指定路径。
- `max_RG_gray(target)`：计算红色和绿色通道的最大值以创建灰度图像（替代方法）。
- `threshold_plt()`: 使用块方式创建二值化阈值图像。它计算小块的平均强度，并将低于某个阈值的像素设置为黑色（0）。
- `threshold_value(target)`：计算图像中特定块的平均强度。
- `threshold_plt2()`: 使用每个像素周围的局部平均值创建二值化阈值图像的另一种方法。
- `canny_image(target)`：将 Canny 边缘检测应用于阈值化图像以识别潜在字符的边缘。
- `tgInfo`: 定义一个类来存储有关潜在目标对象（车牌候选）的信息，包括其位置、尺寸、周长、ID 和与车牌相似度的分数。
- `getTarget(canny, check=False, GRAY=False)`：基于连通分量分析在图像中识别潜在目标对象（车牌候选）。它根据大小和其他标准过滤掉对象。
- `draw_target(target_objs)`：创建一个掩码图像，其中潜在目标对象以黑色（0）标记。
- `filter_target(target_obj)`：根据最小和最大高度和宽度过滤掉目标对象。
- `pointPm(point, GRAY)`：根据点与其周围像素的强度差计算点的“周长分数”。较高的分数表示潜在的边缘点。
- `sort_target(target_objs)`：根据周长分数对目标对象进行排序，分数较高的对象被认为更有可能是车牌。
- `getMaxPmTarget(target_objs, tgmax)`：将返回的目标对象数量限制为指定的最大值。
- `align_target(target_objs, find_best=True)`：尝试根据位置和大小对潜在目标对象进行对齐和分组。它还可以将宽对象拆分为单个字符。它返回对齐/分组的对象、区域的边界矩形以及计算出的旋转角度。
- `target_area(target_objs)`：计算包含所有提供的目标对象的边界矩形的面积。
- `rectangle(target_plt, rec)`：在图像上绘制一个指定区域的矩形。
- `f_height`, `f_width`：定义用于识别车牌号码的字体字符的高度和宽度（可能从字体文件中加载）。
- `FontLoad(file_path="./font.bin")`: 加载包含表示字符形状的二进制数据的字体文件。
- `font_check(standard_font, target_font, x=None, y=None)`：将标准字符形状（来自加载的字体）与图像中的潜在字符形状进行比较。它根据匹配程度计算分数。
- `target_threshold(target_objs)`：创建一个掩码图像，其中潜在目标对象以黑色（0）标记，但也稍微扩展掩码以捕获字符周围的潜在边缘。
- `target_threshold2(target_obj, another_threshold)`：类似于 target_threshold，但使用不同的阈值图像来扩展掩码。
- `rotate_target(target_obj_threshold, target_obj)`：根据计算出的旋转角度旋转目标对象掩码和目标对象信息。

'''
import cv2
import matplotlib.pyplot as plt
import numpy as np
import math

def plate_recognition(box_img):

  global img_height, img_width
  img_height, img_width = box_img.shape[:2]

  global gray
  gray = cv2.cvtColor(box_img, cv2.COLOR_BGR2GRAY)
  #gray = cv2.split(box_img)[1]
  #gray = max_RG_gray(box_img)
  #gray = 255 - gray
  # #plot_show_save(gray, "plot_save/gray")
  #gray = cv2.bilateralFilter(plate, 5,15,15)

  global threshold
  threshold = threshold_plt()
  #threshold = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 0)
  # #plot_show_save(threshold, "plot_save/threshold")

  canny = canny_image(threshold)
  # #plot_show_save(canny, "plot_save/canny")

  target_objs = getTarget(canny)
  target_plt = draw_target(target_objs)
  # #plot_show_save(target_plt, "plot_save/target")

  global skip
  skip = [False for _ in range(len(target_objs))]

  for _ in range(2):
    LP = getLP(target_objs)
    if LP.score > 0:
      break

  if False:
      if LP.score == 0:
        gray = 255 - gray
        threshold = threshold_plt()
        # #plot_show_save(threshold)

        canny = canny_image(threshold)

        target_objs = getTarget(canny)
        target_plt = draw_target(target_objs)
        # #plot_show_save(target_plt, "plot_save/target")
        skip = [False for _ in range(len(target_objs))]

        for _ in range(2):
          LP = getLP(target_objs)
          if LP.score > 0:
            break

  try:
    del img_height, img_width, gray, threshold, skip, inc, rotate, mw, mh, check_mk
  except:
    pass
  if LP.score < 500:
    #print("車牌： no license plate")
    #print("平均符合度：", LP.score)
    return "no_LP"
  else:
    #print("車牌：", LP.LP)
    #print("平均符合度：", LP.score)
    return LP.LP

from os.path import exists, split
from os import mkdir

def plot_show_save(plot, save_path=False):
  plt.imshow(plot, "gray")
  plt.show()

  if save_path:
    fold = split(save_path)[0]
    if not exists(fold) and fold:
      mkdir(fold)

    cv2.imwrite(f"{save_path}.jpg", plot)

def max_RG_gray(target):
  R, G = cv2.split(target)[::-1][:2]
  output = np.fmin(R,G)
  return output

#二值化

block_size = 40

def threshold_plt():
  ny, nx = img_height, img_width #(height, width)
  Th_value = threshold_value(gray)

  threshold = np.full((ny,nx), 255)

  for i in range(1, nx-1):
    x = i // block_size
    for j in range(1, ny-1):
      y = j // block_size
      if gray[j,i] < Th_value[y,x]:
        threshold[j,i] = 0

  return threshold


def threshold_value(target):
  ny, nx = img_height, img_width #(height, width)
  kx = nx // block_size + 1
  ky = ny // block_size + 1

  T = np.zeros((ky, kx))

  for i in range(nx):
    x = i // block_size
    for j in range(ny):
      y = j // block_size
      T[y,x] += target[j,i]
  for i in range(kx):
    for j in range(ky):
      T[j,i] /= block_size**2

  return T

def threshold_plt2():
  ny, nx = img_height, img_width #(height, width)

  threshold = np.full((ny,nx), 255)

  for i in range(1, nx-1):
    for j in range(1, ny-1):
      Th_value = threshold_value2(i, j)
      if gray[j,i] < Th_value:
        threshold[j,i] = 0

  return threshold

def threshold_value2(i, j):
  output = 0
  point_c = 0
  for x in range(i-15, i+16):
    if x < 0:
      continue
    if x >= img_width:
      continue
    for y in range(j-15, j+16):
      if y < 0:
        continue
      if y >= img_height:
        continue
      output += gray[y, x]
      point_c += 1

  return output / point_c

#輪廓
def canny_image(target):
  (height, width) = target.shape #after threshold shape = img_height-1, img_width-1
  #(height, width) = img_height, img_width
  output = np.full((height,width), 255)
  for i in range(1, width-1):
    for j in range(1, height-1):
      if target[j,i] == 255:
        continue
      elif target[j-1, i] == 255:
        output[j,i] = 0
        continue
      elif target[j, i-1] == 255:
        output[j,i] = 0
        continue
      elif target[j+1, i] == 255:
        output[j,i] = 0
        continue
      elif target[j, i+1] == 255:
        output[j,i] = 0

  return output

class tgInfo:
  def __init__(self, x=0, y=0):
    self.np = 0
    self.P = []

    self.xmn = x
    self.xmx = x
    self.ymn = y
    self.ymx = y

    self.cx = 0
    self.cy = 0

    self.width = 0
    self.height = 0

    self.pm = 0
    self.ID = 0

  def copy(self):
    copy_obj = tgInfo()
    for attr, value in self.__dict__.items():
      copy_obj.__setattr__(attr, value)

    return copy_obj

def getTarget(canny, check=False, GRAY=False):
  output = []
  ny, nx = img_height, img_width
  canny_copy = canny.copy()

  for i in range(1, nx-1):
    for j in range(1, ny-1):
      if canny_copy[j, i] == 255:
        continue

      target_obj = tgInfo(i,j)
      target_obj.np = 1

      nc = []
      nc.append((i,j))
      target_obj.P.append((i,j))
      canny_copy[j, i] = 255

      while len(nc) > 0:
        nb = nc[:]
        nc = []
        for p in nb:
          px, py = p
          for ii in range(px-1, px+2):
            for jj in range(py-1, py+2):
              if canny_copy[jj,ii] == 255:
                continue
              k = (ii,jj)
              nc.append(k)
              target_obj.P.append(k)
              target_obj.np += 1

              if ii < target_obj.xmn:
                target_obj.xmn = ii
              if ii > target_obj.xmx:
                target_obj.xmx = ii
              if jj < target_obj.ymn:
                target_obj.ymn = jj
              if jj > target_obj.ymx:
                target_obj.ymx = jj

              canny_copy[jj,ii] = 255

      if isinstance(check, np.ndarray):
        if check[j, i-1] ==0:
          continue
      else:
        if threshold[j, i-1] == 0:
          continue

      target_obj.width = target_obj.xmx - target_obj.xmn + 1
      target_obj.height = target_obj.ymx - target_obj.ymn + 1
      if filter_target(target_obj):
        continue

      target_obj.cx = (target_obj.xmx + target_obj.xmn) / 2
      target_obj.cy = (target_obj.ymx + target_obj.ymn) / 2

      for point in target_obj.P:
        if isinstance(GRAY, np.ndarray):
          pm = pointPm(point, GRAY)
        else:
          pm = pointPm(point, gray)
        if pm > target_obj.pm:
          target_obj.pm = pm

      output.append(target_obj)

  output = sort_target(output)
  return output

def draw_target(target_objs):
  (height, width) = img_height, img_width
  output = np.full((height,width), 255)
  for obj in target_objs:
    for (x,y) in obj.P:
      output[y,x] = 0

  return output

def filter_target(target_obj):
  minHeight = 10
  maxHeight = 80
  minWidth = 2
  maxWidth = 80

  if target_obj.height < minHeight:
    return True
  if target_obj.height > maxHeight:
    return True
  if target_obj.width < minWidth:
    return True
  if target_obj.width > maxWidth:
    return True

  return False

def pointPm(point, GRAY):
  x = point[0]
  y = point[1]

  mx = GRAY[y,x]

  if mx < GRAY[y-1,x]:
    mx = GRAY[y-1,x]
  if mx < GRAY[y+1,x]:
    mx = GRAY[y+1,x]
  if mx < GRAY[y,x-1]:
    mx = GRAY[y,x-1]
  if mx < GRAY[y,x+1]:
    mx = GRAY[y,x+1]

  return mx - GRAY[y,x]

def sort_target(target_objs):
  for i in range(len(target_objs)-1):
    for j in range(i+1, len(target_objs)):
      max_pm_obj_now = target_objs[i]
      seek_obj = target_objs[j]
      if max_pm_obj_now.pm < seek_obj.pm:
        target_objs[i], target_objs[j] = seek_obj, max_pm_obj_now
  target_objs = getMaxPmTarget(target_objs, 30)
  return target_objs

def getMaxPmTarget(target_objs, tgmax):
  i = 0
  output = []
  while i < len(target_objs) and i < tgmax:
    obj = target_objs[i]
    obj.ID = i
    output.append(obj)
    i += 1

  return output

def align_target(target_objs, find_best=True):
  output = []
  pmx = 0
  rec = (0, 0, 0, 0)

  if find_best:
      for i in range(len(target_objs)):
        d = []
        dm = 0

        now_obj = target_objs[i]
        d.append(now_obj)
        dm += now_obj.pm

        x1 = now_obj.cx - now_obj.height*2.5
        x2 = now_obj.cx + now_obj.height*2.5
        y1 = now_obj.cy - now_obj.height*1.25
        y2 = now_obj.cy + now_obj.height*1.25

        #print(f"{i} - dm = {dm}")

        for j in range(len(target_objs)):
          if i == j:
            continue
          if skip[j]:
            continue

          chosen_obj = target_objs[j]
          if chosen_obj.cx < x1:
            continue
          if chosen_obj.cx > x2:
            continue
          if chosen_obj.cy < y1:
            continue
          if chosen_obj.cy > y2:
            continue

          if chosen_obj.height > now_obj.height*1.5:
            continue
          if chosen_obj.height < now_obj.height*0.55:
            continue

          split = False
          if now_obj.height*0.5 < now_obj.width*1.2 and len(d) < 6:
            count = chosen_obj.width // now_obj.width
            if count > 0:
              if chosen_obj.width / now_obj.width - count > 0.95:
                count += 1
            if count > 1 and chosen_obj.height <= now_obj.height*1.2 and chosen_obj.height >= now_obj.height*0.8:
              split = True
              split_objs = []

              ori_width = chosen_obj.width
              n_width = int(ori_width / count)
              #chosen_obj.width = n_width
              for k in range(count):
                split_obj = chosen_obj.copy()
                split_obj.xmn = chosen_obj.xmn + k * n_width
                split_obj.xmx = chosen_obj.xmx - (count - k - 1) * n_width
                split_obj.width = split_obj.xmx - split_obj.xmn
                split_obj.cx = (split_obj.xmx + split_obj.xmn) / 2
                split_objs.append(split_obj)

          if chosen_obj.width > now_obj.height and not split:
            continue

          if split:
            dm += chosen_obj.pm * count
            for obj in split_objs:
              d.append(obj)
          else:
            d.append(chosen_obj)
            dm += chosen_obj.pm

          #print(f"{i} - dm = {dm}, chosen_obj.pm = {chosen_obj.pm}")
          if len(d) >= 7:
            break
        #error
        #print(f"pmx = {pmx}, dm = {dm}") D:\四年級\網路程式設計\car-tw-03.jpg
        area = target_area(d)
        if now_obj.height * now_obj.width * (len(d)-2) > area: #範圍太小略過
          continue

        if dm > pmx:
          pmx = dm
          output = d
          rec = (x1, y1, x2, y2)

  o_count = len(output)

  if not find_best:
    o_count = len(target_objs)
    output = target_objs

  if o_count > 1:
    for i in range(o_count-1):
      for j in range(i+1, o_count):
        now_left = output[i]
        move = output[j]

        if now_left.cx > move.cx:
          output[i], output[j] = move, now_left

  if o_count <= 1:
    dx = 0
    dy = 0
  else:
    dx = output[o_count-1].cx - output[0].cx
    dy = output[o_count-1].cy - output[0].cy

  try:
    inc = math.atan(dy/dx)
  except:
    inc = 0

  return output, rec, inc

def target_area(target_objs):
  obj = target_objs[0]
  x1, x2, y1, y2 = obj.xmn, obj.xmx, obj.ymn, obj.ymx

  for i in range(1, len(target_objs)):
    obj = target_objs[i]
    if x1 > obj.xmn:
      x1 = obj.xmn
    if x2 < obj.xmx:
      x2 = obj.xmx
    if y1 > obj.ymn:
      y1 = obj.ymn
    if y2 < obj.ymx:
      y2 = obj.ymx
  height = y2 - y1
  width = x2 - x1

  return height * width

def rectangle(target_plt, rec):
  x1, y1, x2, y2 = [int(i) for i in rec]

  cx = int((x2+x1)/2)
  cy = int((y2+y1)/2)
  dot = 3
  for i in range(cx-dot, cx+dot):
    for j in range(cy-dot, cy+dot):
      target_plt[j,i] = 0

  height, width = img_height, img_width
  if x1 < 0:
    x1 = 0
  if x2 > width - 1:
    x2 = width - 1
  if y1 < 0:
    y1 = 0
  if y2 > height - 1:
    y2 = height - 1

  for i in range(x1, x2):
    target_plt[y1,i] = 0
    target_plt[y2,i] = 0
  for j in range(y1,y2):
    target_plt[j,x1] = 0
    target_plt[j,x2] = 0

  return target_plt

f_height, f_width = 50, 25

def FontLoad(file_path="./font.bin"):
  with open(file_path,"rb") as f:
    bin = f.read()

  font = np.zeros((2, 36, f_height, f_width), dtype=int)
  font_ex = np.zeros((2, f_height, f_width))

  count = 0
  for m in range(2):
    for n in range(36):
      for j in range(f_height):
        for i in range(f_width):
          b_code = bin[count]
          b_code = 255 if b_code == 0 else 0
          font[m, n, j, i] = b_code
          count += 1

  for n in range(2):
    for j in range(f_height):
      for i in range(f_width):
        b_code = bin[count]
        b_code = 255 if b_code == 0 else 0
        font_ex[n, j, i] = b_code
        count += 1

  return font, font_ex

def font_check(standard_font, target_font, x=None, y=None):
  if x == None and y == None:
    score = 0
    sample_blacks = 0

    for j in range(f_height):
      for i in range(f_width):
        if standard_font[j, i] == 255:
          if target_font[j, i] == 0:
            score -= 1
        else:
          sample_blacks += 1
          if target_font[j, i] == 0:
            score += 1

    return score*1000/sample_blacks
  else:
    score = 0
    sample_blacks = 0

    for j in range(f_height):
      jy = j + y
      if jy > f_height - 1 or jy < 0:
        continue
      for i in range(f_width):
        ix = i + x
        if ix > f_width - 1 or ix < 0:
          continue
        if standard_font[j, i] == 255:
          if target_font[jy, ix] == 0:
            score -= 1
        else:
          sample_blacks += 1
          if target_font[jy, ix] == 0:
            score += 1

    return score*1000/sample_blacks

font, font_ex = FontLoad()

def target_threshold(target_objs):
  (height, width) = img_height, img_width
  output = np.full((height,width), 255)
  for obj in target_objs:
    for (x,y) in obj.P:
      output[y,x] = 0

      i = x + 1
      if i >= width:
        i = width - 1
      while threshold[y,i] == 0:
        output[y,i] = 0
        i += 1

      i = x - 1
      if i < 0:
        i = 0
      while threshold[y,i] == 0:
        output[y,i] = 0
        i -= 1

  return output

def target_threshold2(target_obj, another_threshold):
  (height, width) = img_height, img_width
  output = np.full((height,width), 255)
  obj = target_obj
  for (x,y) in obj.P:
    output[y,x] = 0

    i = x + 1
    if i >= width:
      i = width - 1
    while another_threshold[y,i] == 0:
      output[y,i] = 0
      i += 1

    i = x - 1
    if i < 0:
        i = 0
    while another_threshold[y,i] == 0:
      output[y,i] = 0
      i -= 1

  return output


def rotate_target(target_obj_threshold, target_obj):
  if inc == 0:
    return target_obj_threshold, target_obj

  (height, width) = img_height, img_width
  output = np.full((img_height, img_width), 255)

  x0 = target_obj.xmn
  y0 = target_obj.ymx

  x_move = 0
  y_move = 0
  if target_obj.xmn < target_obj.width:
    x_move = target_obj.width
  if target_obj.xmx > (width - target_obj.width):
    x_move = -target_obj.width
  if target_obj.ymn < target_obj.height:
    y_move = int(target_obj.height / 4)

  rotate_matrix = np.zeros((2,2))
  rotate_matrix[0][0] = math.cos(inc)
  rotate_matrix[0][1] = math.sin(inc)
  rotate_matrix[1][0] = -math.sin(inc)
  rotate_matrix[1][1] = math.cos(inc)

  xmn = width
  xmx = 0
  ymn = height
  ymx = 0

  for i in range(target_obj.xmn, target_obj.xmx+1):
    for j in range(target_obj.ymn, target_obj.ymx+1):
      if target_obj_threshold[j,i] == 255:
        continue

      x = i - x0
      y = y0 - j

      if rotate:
        xx = int(x * rotate_matrix[0][0] + y * rotate_matrix[0][1] + x0) + x_move
      else:
        xx = int(x * rotate_matrix[0][0] + y * rotate_matrix[1][0] + x0) + x_move
      if xx < 1 or xx > width - 2:
        continue

      if rotate:
        yy = int(y0 - (x * rotate_matrix[1][0] + y * rotate_matrix[1][1])) + y_move
      else:
        yy = int(y0 - (x * rotate_matrix[0][1] + y * rotate_matrix[1][1])) + y_move
      if yy < 1 or yy > height - 2:
        continue
      output[yy, xx] = 0

      if xx < xmn:
        xmn = xx
      if xx > xmx:
        xmx = xx
      if yy < ymn:
        ymn = yy
      if yy > ymx:
        ymx = yy

  target_obj = tgInfo()
  target_obj.xmn = xmn
  target_obj.xmx = xmx
  target_obj.ymn = ymn
  target_obj.ymx = ymx

  target_obj.width = xmx - xmn + 1
  target_obj.height = ymx - ymn + 1
  target_obj.cx = (xmx+xmn) / 2
  target_obj.cy = (ymx+ymn) / 2

  for i in range(target_obj.xmn, target_obj.xmx+1):
    for j in range(target_obj.ymn, target_obj.ymx+1):
      if output[j,i] == 0:
        continue
      if (output[j,i-1] + output[j-1,i] + output[j,i+1] + output[j+1,i]) <=255:
        output[j,i] = 0

  return output, target_obj

def normalize_target(target_obj_rotate_threshold, target_obj, mw=0, mh=0):
  if not (mw>0 or mh>0):
    fx = target_obj.width / f_width
    fy = target_obj.height / f_height

    output = np.full((f_height, f_width), 255)

    for i in range(f_width):
      x = int(target_obj.xmn + i * fx)
      for j in range(f_height):
        y = int(target_obj.ymn + j * fy)

        output[j, i] = target_obj_rotate_threshold[y, x]

    return output
  else:
    # fx = (mw * 9 + target_obj.width * 1) / 10 / f_width
    # fy = (mh + target_obj.height) / 2 / f_height
    fx = mw / f_width
    fy = mh / f_height

    output = np.full((f_height, f_width), 255)

    for i in range(f_width):
      sx = 0
      if (target_obj.width / mw) < 0.75:
        sx = (mw - target_obj.width) / 2
        fx = (mw * 0.9 + target_obj.width * 0.1) / f_width


      x = int(target_obj.xmn + i * fx - sx)
      if x < 0 or x > img_width-1:
        continue

      for j in range(f_height):
        y = int(target_obj.ymn + j * fy)
        if y < 0 or y > img_height-1:
          continue

        output[j, i] = target_obj_rotate_threshold[y, x]

    return output

def set_rotate_angle_direction():
  global inc, rotate #有引用inc且對inc進行修改，需宣告為global value
  if inc > 0:
    inc = -inc
    rotate = True # 逆時針還原
  else:
    rotate = False # 順時針還原

def correct_all_target(target_objs):
  rotate_objs = []
  rotate_threshold = []
  w = []
  h = []
  xmn = img_width
  xmx = 0
  ymn = img_height
  ymx = 0

  for obj in target_objs:
    obj_threshold = target_threshold([obj])
    rotate_obj_threshold, rotate_obj = rotate_target(obj_threshold, obj)

    rotate_threshold.append(rotate_obj_threshold)
    rotate_objs.append(rotate_obj)
    w.append(rotate_obj.width)
    h.append(rotate_obj.height)

    if obj.xmn < xmn:
      xmn = obj.xmn
    if obj.xmx > xmx:
      xmx = obj.xmx
    if obj.ymn < ymn:
      ymn = obj.ymn
    if obj.ymx > ymx:
      ymx = obj.ymx

  w.sort()
  h.sort()

  global mw, mh
  try:
    mw = sum(w[-3:-1]) / 2
    mh = sum(h[-3:-1]) / 2
    # mw = w[-2]
    # mh = h[-2]
  except:
    mw = w[0]
    mh = h[0]

  output = np.full((f_height, (f_width+4)*len(target_objs)), 255)
  normalize_objs_threshold = []

  for k in range(len(target_objs)):
    normalize_objs_threshold.append(normalize_target(rotate_threshold[k], rotate_objs[k], mw, mh))

    xs = (f_width+4)*k
    for i in range(f_width):
      for j in range(f_height):
        output[j, i+xs] = normalize_objs_threshold[k][j, i]

  return output, normalize_objs_threshold, rotate_objs, (xmn, xmx, ymn, ymx)

def add_dash(objs_threshold, target_objs):
  mi = find_dash_position(target_objs)

  output = np.full((f_height, (f_width+4)*len(target_objs)+20), 255)
  for k in range(len(target_objs)):
    xs = (f_width+4) * k
    if k > mi:
      xs += 20

    for i in range(f_width):
      for j in range(f_height):
        output[j, i+xs] = objs_threshold[k][j, i]

    if k == mi:
      xs += f_width + 2
      for i in range(5, 15):
        for j in range(23, 28):
          output[j, i+xs] = 0

  return output

def find_dash_position(target_objs):
  dmx = 0
  mi = 0

  for i in range(len(target_objs)-1):
    d = (target_objs[i+1].cx - target_objs[i].cx)**2 + (target_objs[i+1].cy - target_objs[i].cy)**2
    if d > dmx:
      dmx = d
      mi = i

  return mi

Ch = {}
for i in range(36):
  if i < 10:
    Ch[i] = chr(48+i)
  else:
    Ch[i] = chr(65+i-10)

class chInfo:
  def __init__(self):
    self.Ch = ""
    self.ft = 0
    self.kind = 0

def bestC(normalize_obj_threshold):
  C = chInfo()

  for m in range(2):
    for n in range(36):
      for x in range(-1, 2):
        for y in range(-1, 2):
          v = font_check(font[m, n], normalize_obj_threshold, x, y)
          if C.ft < v:
            C.Ch = Ch[n]
            C.ft = v

  for k in range(2):
    for x in range(-1, 2):
      for y in range(-1, 2):
        v = font_check(font_ex[k], normalize_obj_threshold, x, y)
        if C.ft < v:
          C.ft = v
          if k == 0:
            C.Ch = Ch[6]
          else:
            C.Ch = Ch[9]

  return C

class lpInfo:
  def __init__(self):
    self.N = 0
    self.LP = ""
    self.score = 0
    self.kind = 0

    self.xmn = 0
    self.xmx = 0
    self.ymn = 0
    self.ymx = 0

    self.width = 0
    self.height = 0

    self.cx = 0
    self.cy = 0

def getLP(target_objs):
  LP = lpInfo()

  global inc
  target_objs_align, rec, inc = align_target(target_objs)
  set_rotate_angle_direction()
  target_plt = draw_target(target_objs_align)
  target_plt_rec = rectangle(target_plt.copy(), rec)
  # #plot_show_save(target_plt_rec, "plot_save/target_align")

  global skip
  for obj in target_objs_align:
    skip[obj.ID] = True

  objs_count = len(target_objs_align)
  if objs_count < 4:
    return LP

  #print(objs_count, inc)
  LP.N = objs_count

  normalize_threshold, normalize_objs_threshold, target_objs_rotate, maxmin = correct_all_target(target_objs_align)
  # #plot_show_save(normalize_threshold, "plot_save/normalize_threshold")

  LP.xmn, LP.xmx, LP.ymn, LP.ymx = maxmin
  LP.width = LP.xmx - LP.xmn + 1
  LP.height = LP.ymx - LP.ymn + 1
  LP.cx = (LP.xmx - LP.xmn) / 2
  LP.cy = (LP.ymx - LP.ymn) / 2

  # normalize_threshold_dash  = add_dash(normalize_objs_threshold, target_objs_align)
   ## #plot_show_save(normalize_threshold_dash)

  LP = recognize_all_target(LP, normalize_objs_threshold, target_objs_align)

  return LP

def recognize_all_target(LP, objs_threshold, target_objs):
  mi = find_dash_position(target_objs)

  global check_mk
  target_objs_inc, objs_threshold, check_mk = incCorrect(target_objs, objs_threshold)
  # #plot_show_save(add_dash(objs_threshold, target_objs))

  for k in range(len(objs_threshold)):
    C = bestC(objs_threshold[k])
    LP.LP += C.Ch
    LP.score += C.ft
    if k == mi:
      LP.LP += "-"
  LP.score /= len(objs_threshold)

  LP = checkLP(LP, target_objs)

  if LP.LP != "":
    LP = modifyLP(LP, target_objs)

  return LP

def checkLP(LP, target_objs):
  plate_number = LP.LP
  print(LP.score)

  if LP.score < 640:
    return lpInfo()

  if len(plate_number) < 5:
    return lpInfo()

  m = plate_number.index("-")

  if m == 1 and len(plate_number) == 6:
    LP.LP = repair_left_ch(target_objs) + plate_number
    m = LP.LP.index("-")

  if m == 4 and len(plate_number) == 6:
    LP.LP = plate_number + repair_left_ch(target_objs)
    m = LP.LP.index("-")

  if m == 1:
    return lpInfo()

  return LP

def modifyLP(LP, target_objs):
  plate_number = LP.LP

  C = [c for c in plate_number]
  left_length = plate_number.index("-")
  right_length = len(plate_number) - left_length -1

  d1 = 0
  d2 = 0
  if left_length > right_length:
    d1 = 0
    d2 = left_length - 1
  if right_length > left_length:
    d1 = left_length + 1
    d2 = len(plate_number) - 1

  if left_length==3 and right_length==3:
    if check_all_isDigit(C[left_length+1:]):
      add_ch = repair_right_ch(target_objs)
      if add_ch:
        C.append(add_ch)
        d1 = left_length + 1
        d2 = len(C) - 1
        right_length += 1

  if d2 == 0:
    return LP

  for i in range(d1, d2+1):
    C[i] = E2D(C[i])

  if left_length==3 and right_length==4:
    for i in range(3):
      C[i] = D2E(C[i])

  plate_number = ""
  for c in C:
    plate_number += c
  LP.LP = plate_number

  return LP

def E2D(c):
  if c == "B":
    return "8"
  if c == "D":
    return "0"
  if c == "O":
    return "0"
  if c == "I":
    return "1"
  if c == "S":
    return "5"
  if c == "Z":
    return "2"
  return c

def D2E(c):
  if c == "8":
    return "B"
  if c == "0":
    return "D"
  return c

def check_all_isDigit(C):
  for c in C:
    if not c.isdigit():
      return False

  return True

def repair_left_ch(target_objs):
  xd, yd = img_width, img_height
  for i in range(len(target_objs)-1):
    dx = target_objs[i+1].cx - target_objs[i].cx
    if xd > dx:
      xd = dx

    dy = target_objs[i+1].cy - target_objs[i].cy
    if yd > dy:
      yd = dy

  left_obj = target_objs[0].copy()

  left_obj.cx -= xd
  left_obj.cy -= yd

  left_obj.xmn = int(left_obj.cx - mw / 2)
  left_obj.xmx = int(left_obj.cx + mw / 2)
  left_obj.ymn = int(left_obj.cy - mh / 2)
  left_obj.ymx = int(left_obj.cy + mh / 2)
  
  if left_obj.xmn < 0:
    return ""
  if left_obj.xmx >= img_height:
    return ""
  if left_obj.ymn < 0:
    return ""
  if left_obj.ymx >= img_height:
    return ""

  left_obj_threshold = np.full((img_height, img_width), 255)
  for i in range(left_obj.xmn, left_obj.xmx+1):
    for j in range(left_obj.ymn, left_obj.ymx+1):
      left_obj_threshold[j, i] = threshold[j, i]

  canny = canny_image(left_obj_threshold)
  target_objs = getTarget(canny, check=left_obj_threshold)

  if len(target_objs) == 0:
    return ""
  max_obj = target_objs[0]
  max_area = target_area([max_obj])
  for i in range(1, len(target_objs)):
    now_area = target_area([target_objs[i]])
    if max_area < now_area:
      max_area = now_area
      max_obj = target_objs[i]

  left_obj_threshold = target_threshold2(max_obj, left_obj_threshold)

  rotate_obj_threshold, rotate_obj = rotate_target(left_obj_threshold, max_obj)
  normalize_obj_threshold = normalize_target(rotate_obj_threshold, rotate_obj, mw, mh)
  rotate_obj, normalize_obj_threshold, _ = incCorrect([rotate_obj], [normalize_obj_threshold], check_mk)
  # #plot_show_save(normalize_obj_threshold[0])

  c = bestC(normalize_obj_threshold[0])

  if c.ft < 520:
    return ""

  return c.Ch

def repair_right_ch(target_objs):
  xd, yd = img_width, img_height
  for i in range(len(target_objs)-1):
    dx = target_objs[i+1].cx - target_objs[i].cx
    if xd > dx:
      xd = dx

    dy = target_objs[i+1].cy - target_objs[i].cy
    if yd > dy:
      yd = dy

  right_obj = target_objs[-1].copy()

  right_obj.cx += xd
  right_obj.cy += yd

  right_obj.xmn = int(right_obj.cx - mw / 2)
  right_obj.xmx = int(right_obj.cx + mw / 2)
  right_obj.ymn = int(right_obj.cy - mh / 2)
  right_obj.ymx = int(right_obj.cy + mh / 2)
  
  if right_obj.xmn < 0:
    return ""
  if right_obj.xmx >= img_height:
    return ""
  if right_obj.ymn < 0:
    return ""
  if right_obj.ymx >= img_height:
    return ""

  right_obj_threshold = np.full((img_height, img_width), 255)
  for i in range(right_obj.xmn, right_obj.xmx+1):
    for j in range(right_obj.ymn, right_obj.ymx+1):
      right_obj_threshold[j, i] = threshold[j, i]

  canny = canny_image(right_obj_threshold)
  target_objs = getTarget(canny, check=right_obj_threshold)

  if len(target_objs) == 0:
    return ""
  max_obj = target_objs[0]
  max_area = target_area([max_obj])
  for i in range(1, len(target_objs)):
    now_area = target_area([target_objs[i]])
    if max_area < now_area:
      max_area = now_area
      max_obj = target_objs[i]

  right_obj_threshold = target_threshold2(max_obj, right_obj_threshold)

  rotate_obj_threshold, rotate_obj = rotate_target(right_obj_threshold, max_obj)
  normalize_obj_threshold = normalize_target(rotate_obj_threshold, rotate_obj, mw, mh)
  rotate_obj, normalize_obj_threshold, _ = incCorrect([rotate_obj], [normalize_obj_threshold], check_mk)
  # #plot_show_save(normalize_obj_threshold[0])

  c = bestC(normalize_obj_threshold[0])

  if c.ft < 520:
    return ""

  return c.Ch

def plate_plot(objs_threshold):
  wd = f_width + (f_width+2)*len(objs_threshold) + f_width
  output = np.full((f_height, wd), 255)
  for k in range(len(objs_threshold)):
    xs = f_width + (f_width+2) * k
    for i in range(f_width):
      for j in range(f_height):
        output[j, xs+i] = objs_threshold[k][j,i]
  return output

def incCorrect(target_objs, objs_threshold, check=None):
  ori_LP_threshold = plate_plot(objs_threshold)
  wd = f_width + (f_width+2)*len(target_objs) + f_width
  global img_width
  if img_width < wd+10:
    img_width = wd + 10

  max_white_lines = 0
  mk = 0

  best_result = np.full((f_height, wd), 255)
  if check == None:
    modify = True
    for sx in range(-15, 17):
      test_plate = np.full((f_height, wd), 255)

      f = sx / (f_height-1)
      for j in range(f_height):
        dx = int(f * (f_width - 1 - j))
        for i in range(wd):
          x = i + dx

          if x < 0 or x > wd - 1:
            continue
          test_plate[j, x] = ori_LP_threshold[j, i]

      white_lines = 0
      for i in range(wd):
        blacks = 0
        for j in range(f_height):
          if test_plate[j, i] == 0:
            blacks += 1
            break

        if blacks == 0:
          white_lines += 1

      if modify and max_white_lines == white_lines:
        max_white_lines = white_lines
        mk = sx
        best_result = test_plate
        modify = False
      if max_white_lines < white_lines:
        max_white_lines = white_lines
        mk = sx
        best_result = test_plate
        modify = True

  elif check != 0:
    f = check / (f_height-1)
    for j in range(f_height):
      dx = int(f * (f_width - 1 - j))
      for i in range(wd):
        x = i + dx

        if x < 0 or x > wd - 1:
          continue
        best_result[j, x] = ori_LP_threshold[j, i]

  if mk != 0:
    # #plot_show_save(best_result)
    plate_threshold = np.full((img_height, img_width), 255)
    for i in range(wd):
      for j in range(f_height):
        plate_threshold[j+10, i+10] = best_result[j, i]

    canny = canny_image(plate_threshold)
    target_objs = getTarget(canny, check=plate_threshold, GRAY=plate_threshold)
    target_objs_align, _, _ = align_target(target_objs, find_best=False)

    w = []
    h = []
    xmn = img_width
    xmx = 0
    ymn = img_height
    ymx = 0

    objs_threshold = []
    for obj in target_objs_align:
      objs_threshold.append(target_threshold2(obj, plate_threshold))

      w.append(obj.width)
      h.append(obj.height)

      if obj.xmn < xmn:
        xmn = obj.xmn
      if obj.xmx > xmx:
        xmx = obj.xmx
      if obj.ymn < ymn:
        ymn = obj.ymn
      if obj.ymx > ymx:
        ymx = obj.ymx

    w.sort()
    h.sort()

    global mw, mh
    try:
      mw = sum(w[-3:-1]) / 2
      mh = sum(h[-3:-1]) / 2
      # mw = w[-2]
      # mh = h[-2]
    except:
      mw = w[0]
      mh = h[0]

    normalize_objs_threshold = []

    for k in range(len(target_objs_align)):
      normalize_objs_threshold.append(normalize_target(objs_threshold[k], target_objs_align[k], mw, mh))

    return target_objs_align, normalize_objs_threshold, mk
  else:
    return target_objs, objs_threshold, 0

if __name__ == "__main__":
    box_img = cv2.imread("F:/test_material/plate1.jpg")
    #box_img = cv2.imread("car-tw-03.jpg")

    #box_img = cv2.imread("car.jpg") #C07 car.jpg
    #box_img = cv2.imread("test/car03.webp")
    #box_img = cv2.imread("test/car07.webp")

    box_img = cv2.imread("F:/test_material/test2.jpg") # 3B2-KBB wrong

    print(plate_recognition(box_img))
    